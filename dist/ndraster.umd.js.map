{"version":3,"file":"ndraster.umd.js","sources":["../src/NdRaster.js","../src/index.js"],"sourcesContent":["\n/* global BigUint64Array, BigInt64Array */\n/* eslint no-undef: \"error\" */\n\nconst DEFAULT = {\n  dtype: 'float64',\n  copy: false,\n}\n\n\nconst DTYPE_TO_TYPEDARRAY_CONSTRUCTOR = {\n  uint8: Uint8Array,\n  int8: Int8Array,\n  uint16: Uint16Array,\n  int16: Int16Array,\n  uint32: Uint32Array,\n  int32: Int32Array,\n  uint64: BigUint64Array,\n  int64: BigInt64Array,\n  float32: Float32Array,\n  float64: Float64Array,\n}\n\nconst DTYPE_TO_NB_POSIBLE_VALUES = {\n  uint8: 2 ** (Uint8Array.BYTES_PER_ELEMENT * 8),\n  int8: 2 ** (Int8Array.BYTES_PER_ELEMENT * 8),\n  uint16: 2 ** (Uint16Array.BYTES_PER_ELEMENT * 8),\n  int16: 2 ** (Int16Array.BYTES_PER_ELEMENT * 8),\n  uint32: 2 ** (Uint32Array.BYTES_PER_ELEMENT * 8),\n  int32: 2 ** (Int32Array.BYTES_PER_ELEMENT * 8),\n  uint64: 2 ** (BigUint64Array.BYTES_PER_ELEMENT * 8),\n  int64: 2 ** (BigInt64Array.BYTES_PER_ELEMENT * 8),\n  float32: Infinity,\n  float64: Infinity,\n}\n\nconst DTYPE_TO_BOUND = {\n  uint8: {\n    min: 0,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint8 - 1,\n  },\n  int8: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int8 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int8 / 2 - 1,\n  },\n  uint16: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint16 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint16 / 2 - 1,\n  },\n  int16: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int16 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int16 / 2 - 1,\n  },\n  uint32: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint32 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint32 / 2 - 1,\n  },\n  int32: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int32 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int32 / 2 - 1,\n  },\n  uint64: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint64 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint64 / 2 - 1,\n  },\n  int64: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int64 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int64 / 2 - 1,\n  },\n  float32: {\n    min: -Infinity,\n    max: Infinity,\n  },\n  float64: {\n    min: -Infinity,\n    max: +Infinity,\n  },\n}\n\n\nclass NdRaster {\n  /**\n   * @constructor\n   * @param {Array|Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|BigUint64Array|BigInt64Array|Float32Array|Float64Array} data - can be a generic Array or one of the typedArray.\n   * If it is a generic Array, the values will be copied in a typed array (default dtype or dtype in the options object).\n   * If it is a typed array, a reference will be used and the values will not be copied, unless `options.copy` is explicitelly set to true or `options.dtype` does not matchc the type of the provided data.\n   * @param {Object} options - the options object\n   * @param {string} options.dtype - the data type to enforce the data to be. Must be one of 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', 'uint64', 'int64', 'float32', 'float64' (default: 'float64')\n   * @param {boolean} options.copy - if false, the inner data of the NdRaster instance will be a reference (unless another dtype is provided). If true, the data will be deep copied (default: false)\n   * @param {Array} options.shape - the shape to provide to the data, important to interpret the data as a multi-dimensional dataset.\n   *        Example: shape must be like [number, number, number] for a 3D matrix, where the first element is the size of the slowest dimension\n   *                 and the last element is the size of the fastest dimension. Numpy refers to this as the 'C' order, in opposition to the 'F' (Fortran) order.\n   *                 This order is also the default order used in Numpy.\n   *                 (default: single dimension of the size of the provided array)\n   */\n  constructor(arr, options = {}) {\n    const providedDtype = 'dtype' in options ? options.dtype : null\n    const copy = 'copy' in options ? (!!options.copy) : false\n    let shape = 'shape' in options ? options.shape : null\n\n    this._data = null\n    this._dtype = null\n    this._shape = null\n    this._strides = null\n\n    // if dtype provided in option but not valid, we throw an Error\n    if (providedDtype && !NdRaster.isValidDtype(providedDtype)) {\n      throw new Error(`The value ${providedDtype} is not a valid dtype.`)\n    }\n\n    const guessedDtype = NdRaster.guessDtype(arr)\n    const dtypeToUse = providedDtype ? providedDtype : DEFAULT.dtype\n    const isGenericArray = NdRaster.isGenericArray(arr)\n\n    if (isGenericArray\n    || (guessedDtype !== dtypeToUse && providedDtype)\n    || copy) {\n      let arrData = arr\n\n      // if a generic Array is provided, it could be a nested array\n      if (isGenericArray) {\n        const arrConfig = NdRaster.flattenNestedArray(arr)\n        arrData = arrConfig.array\n\n        // if no shape is provided, then we use the shape deduced by the flattening\n        if (!shape) {\n          shape = arrConfig.shape\n        }\n      }\n\n      this._data = NdRaster.copyDataAsType(arrData, dtypeToUse)\n      this._dtype = dtypeToUse\n    } else if (guessedDtype && copy) { // the type could be guessed but it was explicitely expressed to copy\n      this._data = NdRaster.copyDataAsType(arr, guessedDtype)\n      this._dtype = dtypeToUse\n    } else if (guessedDtype && !copy) { // the type could be guessed and it was not express to copy, we just assign\n      this._data = arr\n      this._dtype = guessedDtype\n    } else {\n      throw new Error('The provided data array is not valid.')\n    }\n\n    if (shape) {\n      this.shape = shape\n    } else {\n      this.shape = [this._data.length]\n    }\n\n    this._typeBound = DTYPE_TO_BOUND[this._dtype]\n  }\n\n\n  /**\n   * Define the shape of the data.\n   * @param {Array} shape - the shape to provide to the data, important to interpret the data as a multi-dimensional dataset.\n   *        Example: shape must be like [number, number, number] for a 3D matrix, where the first element is the size of the slowest dimension\n   *                 and the last element is the size of the fastest dimension. Numpy refers to this as the 'C' order, in opposition to the 'F' (Fortran) order.\n   *                 This order is also the default order used in Numpy.\n   *                 (default: single dimension of the size of the provided array)\n   */\n  set shape(shape) {\n    let total = 1\n\n    if (!Array.isArray(shape)) {\n      throw new Error('The shape must be an Array')\n    }\n\n    for (let i = 0; i < shape.length; i += 1) {\n      total *= shape[i]\n    }\n\n    if (total !== this._data.length) {\n      throw new Error('The shape does not match the size of the data. All the elements of the shape multiplied must be the total number of element in the data.')\n    }\n\n    this._shape = shape.slice()\n    this._strides = new Array(shape.length).fill(0)\n    this._strides[this._shape.length - 1] = 1\n\n    for (let i = this._shape.length - 2; i >= 0; i -= 1) {\n      this._strides[i] = this._shape[i + 1] * this._strides[i + 1]\n    }\n  }\n\n\n  /**\n   * Get the shape of this NdRaster (or rather a copy of it)\n   * @returns {Array}\n   */\n  get shape() {\n    return this._shape.slice()\n  }\n\n\n  /**\n   * Get the dtype as a string (read only)\n   * @returns {string}\n   */\n  get dtype() {\n    return this._dtype\n  }\n\n\n  /**\n   * Get the stride (read only)\n   */\n  get strides() {\n    return this._strides.slice()\n  }\n\n\n  /**\n   * Get the raw data as a 1D typed array with data arranged in 'C' order\n   * @returns {TYpedArray}\n   */\n  get data() {\n    return this._data\n  }\n\n\n  /**\n   * Get the minimum and maximum values possible by the dtype.\n   * Note: this is not the data min-max\n   * @return {Object} of shape {min: number, max: number}\n   */\n  get bounds() {\n    // making it read only to prevent any modification\n    return {\n      min: this._typeBound.min,\n      max: this._typeBound.max,\n    }\n  }\n\n\n  /**\n   * Get the number of dimensions in this NdRaster\n   * @returns {number}\n   */\n  get dimensions() {\n    return this._shape.length\n  }\n\n\n  /**\n   * Get the value at a given position\n   * @param {Array} position - the position as [number, number, ...] with as many components as there are dimensions in the NdRaster.\n   * @returns {number}\n   */\n  get(position) {\n    this._throwIfInvalidPosition(position)\n\n    let dataOffset = 0\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    return this._data[dataOffset]\n  }\n\n\n  /**\n   * Set the value at a given position.\n   * This value is bounded to the dtype capabilities to prevent looping,\n   * for example, is dtype is 'uint8' and a value is set at 300, then the actual\n   * value put in the NdRaster will be 255, as it is the maximum value possible for 'uint8' type.\n   * Know more about the boudaries for this NdRaster with the attribute `.bounds`\n   * @param {Array} position - position to change to change the value of. Must contain as many elements as there are dimensions in this NdRaster\n   * @param {number} value\n   */\n  set(position, value) {\n    // eslint-disable-next-line no-restricted-globals\n    if (isNaN(value)) {\n      throw new Error('The value must be a number')\n    }\n\n    this._throwIfInvalidPosition(position)\n\n    let boundedValue = value\n    let dataOffset = 0\n\n    if (value < this._typeBound.min) {\n      boundedValue = this._typeBound.min\n    }\n\n    if (value > this._typeBound.max) {\n      boundedValue = this._typeBound.max\n    }\n\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    this._data[dataOffset] = boundedValue\n  }\n\n\n\n\n\n  /**\n   * @private\n   * Throw an error if position is invalid.\n   * @param {*} position\n   */\n  _throwIfInvalidPosition(position) {\n    if (position.length !== this._shape.length) {\n      throw new Error(`The position argument contains ${position.length} elements instead of ${this._shape.length}.`)\n    }\n\n    for (let i = 0; i < position.length; i += 1) {\n      if (position[i] < 0 || position[i] > this._shape[i] - 1) {\n        throw new Error(`The position components ${i} is out of bound. Must be in [0, ${this._shape[i] - 1}]`)\n      }\n    }\n  }\n\n\n  copy(options = {}) {\n    const dtype = 'dtype' in options ? options.dtype : this._dtype\n\n    if (!(dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The provided dtype is not valid')\n    }\n\n    let dataCopy = null\n    if (dtype === this._dtype) {\n      dataCopy = this._data.slice()\n    } else {\n      dataCopy = NdRaster.copyDataAsType(this._data, dtype)\n    }\n\n    const copy = new NdRaster(dataCopy, {\n      copy: false,\n      shape: this.shape,\n    })\n    return copy\n  }\n\n\n  /**\n   * \n   * @param {*} start \n   * @param {*} end \n   */\n  slice(start, end) {\n\n  }\n\n\n  /**\n   * @static\n   * Tells if a dtype is valid\n   * @param {string} dtype - a dtype as a string\n   * @returns {boolean}\n   */\n  static isValidDtype(dtype) {\n    return dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR\n  }\n\n\n  /**\n   * @static\n   * Tells the dtype of the given array. If no dtype is found, `null`  is returned.\n   * @param {*} arr - Some value that may or may not be a typed array\n   * @returns {string|null}\n   */\n  static guessDtype(arr) {\n    const dtypes = Object.keys(DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)\n    for (let i = 0; i < dtypes.length; i += 1) {\n      const dtype = dtypes[i]\n      if (arr instanceof DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[dtype]) {\n        return dtype\n      }\n    }\n    return null\n  }\n\n\n  /**\n   * @static\n   * Tells if a value is of type Array.\n   * Note: this function will return false if the value is a typed array\n   * @param {*} arr\n   */\n  static isGenericArray(arr) {\n    return (arr instanceof Array)\n  }\n\n\n  /**\n   * @static\n   * Get the shape of a nested array. A nested array is a generic Array that contains other arrays\n   * such as [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]] which a a 2D array of dimension ('C' ordered) [4, 3]\n   * @param {Array} arr - the potentially multidimensional nested array\n   * @returns {Array|null} Return a dimension array where the first element is the size of the slowest varying dimension\n   * and the last element is the fastest varying dimension. Returns null if the array is not valid\n   */\n  static getNestedArrayShape(arr) {\n    const shape = []\n\n    if (!Array.isArray(arr)) {\n      throw new Error('The value provided is not an Array')\n    }\n\n    let arrDigger = arr\n\n    while (Array.isArray(arrDigger)) {\n      const len = arrDigger.length\n      if (len === 0) {\n        throw new Error('An empty array cannot be used as data.')\n      }\n      shape.push(len)\n      arrDigger = arrDigger[0]\n    }\n\n    return shape\n  }\n\n\n  /**\n   * @static\n   * Flattens a nested Array and get the shape\n   * @param {Array} arr - a potentially nested Array\n   * @returns {Object} like {array: Array, shape: Array}\n   */\n  static flattenNestedArray(arr) {\n    const shape = NdRaster.getNestedArrayShape(arr)\n    const array = arr.flat(shape.length)\n    const expectedLength = shape.reduce((a, b) => a * b)\n\n    // this ensures that all the element in a given dimension have the same size\n    if (expectedLength !== array.length) {\n      throw new Error('The provided nested Array has size inconsistencies.')\n    }\n\n    return {\n      array,\n      shape,\n    }\n  }\n\n  static copyDataAsType(arr, targetDtype) {\n    if (!(targetDtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The target dtype is not valid.')\n    }\n\n    const guessedDtype = NdRaster.guessDtype(arr)\n\n    if (guessedDtype === targetDtype) {\n      return arr.slice()\n    }\n\n    const bounds = DTYPE_TO_BOUND[targetDtype]\n    const arrCopy = new DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[targetDtype](arr.length)\n    const length = arr.length\n\n    for (let i = 0; i < length; i += 1) {\n      let boundedValue = arr[i]\n      if (boundedValue < bounds.min) {\n        boundedValue = bounds.min\n      } else if (boundedValue > bounds.max) {\n        boundedValue = bounds.max\n      }\n      arrCopy[i] = boundedValue\n    }\n    return arrCopy\n  }\n}\n\nexport default NdRaster\n\n\n  // TODO:\n  // copy/clone/astype\n  // stat (min max)\n  // get multiple values at once (all dim) --> slice\n  // forEach\n  // simple operator + - / * (with scalar and other NdRasters) --> create a new one\n  // Constructor: data should be optional but at least one of data and shape must be provided","import NdRaster from './NdRaster'\n\nexport default ({\n  NdRaster,\n})\n"],"names":[],"mappings":"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"}