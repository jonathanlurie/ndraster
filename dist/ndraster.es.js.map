{"version":3,"file":"ndraster.es.js","sources":["../src/NdRaster.js","../src/index.js"],"sourcesContent":["/* global BigUint64Array, BigInt64Array */\n/* eslint no-undef: \"error\" */\n/* eslint-disable no-bitwise */\n\nconst DEFAULT = {\n  dtype: 'float64',\n  copy: false,\n}\n\n\nconst DTYPE_TO_TYPEDARRAY_CONSTRUCTOR = {\n  uint8: Uint8Array,\n  int8: Int8Array,\n  uint16: Uint16Array,\n  int16: Int16Array,\n  uint32: Uint32Array,\n  int32: Int32Array,\n  uint64: BigUint64Array,\n  int64: BigInt64Array,\n  float32: Float32Array,\n  float64: Float64Array,\n}\n\nconst DTYPE_TO_NB_POSIBLE_VALUES = {\n  uint8: 2 ** (Uint8Array.BYTES_PER_ELEMENT * 8),\n  int8: 2 ** (Int8Array.BYTES_PER_ELEMENT * 8),\n  uint16: 2 ** (Uint16Array.BYTES_PER_ELEMENT * 8),\n  int16: 2 ** (Int16Array.BYTES_PER_ELEMENT * 8),\n  uint32: 2 ** (Uint32Array.BYTES_PER_ELEMENT * 8),\n  int32: 2 ** (Int32Array.BYTES_PER_ELEMENT * 8),\n  uint64: 2 ** (BigUint64Array.BYTES_PER_ELEMENT * 8),\n  int64: 2 ** (BigInt64Array.BYTES_PER_ELEMENT * 8),\n  float32: Infinity,\n  float64: Infinity,\n}\n\nconst DTYPE_TO_BOUND = {\n  uint8: {\n    min: 0,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint8 - 1,\n  },\n  int8: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int8 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int8 / 2 - 1,\n  },\n  uint16: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint16 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint16 / 2 - 1,\n  },\n  int16: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int16 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int16 / 2 - 1,\n  },\n  uint32: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint32 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint32 / 2 - 1,\n  },\n  int32: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int32 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int32 / 2 - 1,\n  },\n  uint64: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint64 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint64 / 2 - 1,\n  },\n  int64: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int64 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int64 / 2 - 1,\n  },\n  float32: {\n    min: -Infinity,\n    max: Infinity,\n  },\n  float64: {\n    min: -Infinity,\n    max: +Infinity,\n  },\n}\n\n\nclass NdRaster {\n  /**\n   * @constructor\n   * @param {Array|Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|BigUint64Array|BigInt64Array|Float32Array|Float64Array} data - can be a generic Array or one of the typedArray.\n   * If it is a generic Array, the values will be copied in a typed array (default dtype or dtype in the options object).\n   * If it is a typed array, a reference will be used and the values will not be copied, unless `options.copy` is explicitelly set to true or `options.dtype` does not matchc the type of the provided data.\n   * @param {Object} options - the options object\n   * @param {string} options.dtype - the data type to enforce the data to be. Must be one of 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', 'uint64', 'int64', 'float32', 'float64' (default: 'float64')\n   * @param {boolean} options.copy - if false, the inner data of the NdRaster instance will be a reference (unless another dtype is provided). If true, the data will be deep copied (default: false)\n   * @param {Array} options.shape - the shape to provide to the data, important to interpret the data as a multi-dimensional dataset.\n   *        Example: shape must be like [number, number, number] for a 3D matrix, where the first element is the size of the slowest dimension\n   *                 and the last element is the size of the fastest dimension. Numpy refers to this as the 'C' order, in opposition to the 'F' (Fortran) order.\n   *                 This order is also the default order used in Numpy.\n   *                 (default: single dimension of the size of the provided array)\n   */\n  constructor(options = {}) {\n    const providedDtype = 'dtype' in options ? options.dtype : null\n    const copy = 'copy' in options ? (!!options.copy) : false\n    let shape = 'shape' in options ? options.shape : null\n    const arr = 'data' in options ? options.data : null\n\n    if (!shape && !arr) {\n      throw new Error('At least a shape of a data array is expected to construct a NdRaster.')\n    }\n\n    this._data = null\n    this._dtype = null\n    this._shape = null\n    this._strides = null\n\n    // if dtype provided in option but not valid, we throw an Error\n    if (providedDtype && !NdRaster.isValidDtype(providedDtype)) {\n      throw new Error(`The value ${providedDtype} is not a valid dtype.`)\n    }\n\n    const guessedDtype = NdRaster.guessDtype(arr)\n    const dtypeToUse = providedDtype ? providedDtype : DEFAULT.dtype\n    const isGenericArray = NdRaster.isGenericArray(arr)\n\n    if (!arr && shape) {\n      const expectedLength = shape.reduce((a, b) => a * b)\n      this._data = new DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[dtypeToUse](expectedLength)\n    } else if (isGenericArray\n    || (guessedDtype !== dtypeToUse && providedDtype)\n    || copy) {\n      let arrData = arr\n\n      // if a generic Array is provided, it could be a nested array\n      if (isGenericArray) {\n        const arrConfig = NdRaster.flattenNestedArray(arr)\n        arrData = arrConfig.array\n\n        // if no shape is provided, then we use the shape deduced by the flattening\n        if (!shape) {\n          shape = arrConfig.shape\n        }\n      }\n\n      this._data = NdRaster.copyDataAsType(arrData, dtypeToUse)\n      this._dtype = dtypeToUse\n    } else if (guessedDtype && copy) { // the type could be guessed but it was explicitely expressed to copy\n      this._data = NdRaster.copyDataAsType(arr, guessedDtype)\n      this._dtype = dtypeToUse\n    } else if (guessedDtype && !copy) { // the type could be guessed and it was not express to copy, we just assign\n      this._data = arr\n      this._dtype = guessedDtype\n    } else {\n      throw new Error('The provided data array is not valid.')\n    }\n\n    if (shape) {\n      this.shape = shape\n    } else {\n      this.shape = [this._data.length]\n    }\n\n    this._typeBound = DTYPE_TO_BOUND[this._dtype]\n  }\n\n\n  /**\n   * Define the shape of the data.\n   * @param {Array} shape - the shape to provide to the data, important to interpret the data as a multi-dimensional dataset.\n   *        Example: shape must be like [number, number, number] for a 3D matrix, where the first element is the size of the slowest dimension\n   *                 and the last element is the size of the fastest dimension. Numpy refers to this as the 'C' order, in opposition to the 'F' (Fortran) order.\n   *                 This order is also the default order used in Numpy.\n   *                 (default: single dimension of the size of the provided array)\n   */\n  set shape(shape) {\n    let total = 1\n\n    if (!Array.isArray(shape)) {\n      throw new Error('The shape must be an Array')\n    }\n\n    for (let i = 0; i < shape.length; i += 1) {\n      total *= shape[i]\n    }\n\n    if (total !== this._data.length) {\n      throw new Error('The shape does not match the size of the data. All the elements of the shape multiplied must be the total number of element in the data.')\n    }\n\n    this._shape = shape.slice()\n    this._strides = new Array(shape.length).fill(0)\n    this._strides[this._shape.length - 1] = 1\n\n    for (let i = this._shape.length - 2; i >= 0; i -= 1) {\n      this._strides[i] = this._shape[i + 1] * this._strides[i + 1]\n    }\n  }\n\n\n  /**\n   * Get the shape of this NdRaster (or rather a copy of it)\n   * @returns {Array}\n   */\n  get shape() {\n    return this._shape.slice()\n  }\n\n\n  /**\n   * Get the dtype as a string (read only)\n   * @returns {string}\n   */\n  get dtype() {\n    return this._dtype\n  }\n\n\n  /**\n   * Get the stride (read only)\n   */\n  get strides() {\n    return this._strides.slice()\n  }\n\n\n  /**\n   * Get the raw data as a 1D typed array with data arranged in 'C' order\n   * @returns {TYpedArray}\n   */\n  get data() {\n    return this._data\n  }\n\n\n  /**\n   * Get the minimum and maximum values possible by the dtype.\n   * Note: this is not the data min-max\n   * @return {Object} of shape {min: number, max: number}\n   */\n  get bounds() {\n    // making it read only to prevent any modification\n    return {\n      min: this._typeBound.min,\n      max: this._typeBound.max,\n    }\n  }\n\n\n  /**\n   * Get the number of dimensions in this NdRaster\n   * @returns {number}\n   */\n  get dimensions() {\n    return this._shape.length\n  }\n\n\n  /**\n   * Get the value at a given position\n   * @param {Array} position - the position as [number, number, ...] with as many components as there are dimensions in the NdRaster.\n   * @returns {number}\n   */\n  get(position) {\n    this._throwIfInvalidPosition(position)\n\n    let dataOffset = 0\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    return this._data[dataOffset]\n  }\n\n\n  /**\n   * Set the value at a given position.\n   * This value is bounded to the dtype capabilities to prevent looping,\n   * for example, is dtype is 'uint8' and a value is set at 300, then the actual\n   * value put in the NdRaster will be 255, as it is the maximum value possible for 'uint8' type.\n   * Know more about the boudaries for this NdRaster with the attribute `.bounds`\n   * @param {Array} position - position to change to change the value of. Must contain as many elements as there are dimensions in this NdRaster\n   * @param {number} value\n   */\n  set(position, value) {\n    // eslint-disable-next-line no-restricted-globals\n    if (isNaN(value)) {\n      throw new Error('The value must be a number')\n    }\n\n    this._throwIfInvalidPosition(position)\n\n    let boundedValue = value\n    let dataOffset = 0\n\n    if (value < this._typeBound.min) {\n      boundedValue = this._typeBound.min\n    }\n\n    if (value > this._typeBound.max) {\n      boundedValue = this._typeBound.max\n    }\n\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    this._data[dataOffset] = boundedValue\n  }\n\n\n  /**\n   * @private\n   * Get the ND position from the 1D buffer position\n   * @param {number} offset - offset within the 1D data buffer\n   * @return {Array}\n   */\n  _bufferOffsetToPositionND(offset) {\n    if (offset < 0 || offset >= this._data.length) {\n      throw new Error('Position 1D is out of bound.')\n    }\n\n    const posND = this._shape.slice().fill(0)\n    let r = offset\n\n    for (let i = 0; i < posND.length; i += 1) {\n      posND[i] = ~~(r / this._strides[i])\n      r %= this._strides[i]\n    }\n\n    return posND\n  }\n\n\n  /**\n   * Get the buffer position from a ND position\n   * @param {Array} position - the position in ND\n   * @returns {number}\n   */\n  _positionNDToBufferOffset(position) {\n    this._throwIfInvalidPosition(position)\n    let dataOffset = 0\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    return dataOffset\n  }\n\n\n  /**\n   * @private\n   * Throw an error if position is invalid.\n   * @param {*} position\n   */\n  _throwIfInvalidPosition(position) {\n    if (position.length !== this._shape.length) {\n      throw new Error(`The position argument contains ${position.length} elements instead of ${this._shape.length}.`)\n    }\n\n    for (let i = 0; i < position.length; i += 1) {\n      if (position[i] < 0 || position[i] > this._shape[i] - 1) {\n        throw new Error(`The position components ${i} is out of bound. Must be in [0, ${this._shape[i] - 1}]`)\n      }\n    }\n  }\n\n\n  /**\n   * Create a deep copy of this NdRaster. The copy will not share any buffer with this NdRaster.\n   * @param {Object} options - The options object\n   * @param {string} options.dtype - If the dtype of the copy. Data will be clamped if necessary\n   * @return {NdRaster}\n   */\n  copy(options = {}) {\n    const dtype = 'dtype' in options ? options.dtype : this._dtype\n\n    if (!(dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The provided dtype is not valid')\n    }\n\n    let dataCopy = null\n    if (dtype === this._dtype) {\n      dataCopy = this._data.slice()\n    } else {\n      dataCopy = NdRaster.copyDataAsType(this._data, dtype)\n    }\n\n    const copy = new NdRaster({\n      data: dataCopy,\n      copy: false,\n      shape: this.shape,\n    })\n    return copy\n  }\n\n\n  /**\n   * Make a copy of this NdRaster but with data of a different dtype.\n   * This is a shorthand to the .copy() method.\n   * The data of the new NdRaster will not share buffer with this one.\n   * @param {string} dtype - dtype of the new NdRaster\n   * @returns {NdRaster}\n   */\n  asType(dtype) {\n    return this.copy({ dtype })\n  }\n\n\n  /**\n   * Slice this NdRaster\n   * @param {Object} options - the option object\n   * @param {Array} options.min - N-dimensional position of the lower bound of the dataset. In an array such as [number, number, number, ...] from the slowest varying to the fastest (default: origin, such as [0, 0, ..., 0])\n   * @param {Array} options.max - N-dimensional position of the upper bound of the dataset. In an array such as [number, number, number, ...] from the slowest varying to the fastest (default: upper boundaries of the dataset)\n   * @param {string} options.dtype - enforce a dtype that is different from the original dtype of the dataset\n   * @param {boolean} options.strict - in strict mode (true), the min and max are expected to be within the boundaries of the original NdRaster and will throw an error otherwise. In non-strict mode, the min and max will be recomputed to be contrained to the boundaries (default: false)\n   * @returns {NdRaster}\n   */\n  slice(options = {}) {\n    let min = 'min' in options ? options.min : this._shape.slice().fill(0)\n    let max = 'max' in options ? options.max : this.shape\n    const dtype = 'dtype' in options ? options.dtype : this._dtype\n    const strict = 'strict' in options ? !!options.strict : false\n\n    if (!(dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The provided dtype does not exist.')\n    }\n\n    // If a full copy is asked, then it's faster with the copy method\n    if (!('min' in options) && !('max' in options)) {\n      return this.copy(options)\n    }\n\n    // checking that provided boundaries are compliant to the dataset\n    if (min.length !== this._shape.length || max.length !== this._shape.length) {\n      throw new Error(`The boundaries must contain ${this._shape.length} elements.`)\n    }\n\n    if (strict) {\n      for (let i = 0; i < min.length; i += 1) {\n        if (min[i] < 0\n        || min[i] > this._shape[i] - 1\n        || max[i] < 1\n        || max[i] > this._shape) {\n          throw new Error(`The largest boundaries possible for the ${i}th dimension are [0, ${this._shape[i]}]`)\n        }\n      }\n    } else {\n      min = min.map((el) => Math.max(el, 0))\n      max = max.map((el, i) => Math.min(el, this._shape[i]))\n    }\n\n    const sliceShape = max.map((el, i) => el - min[i])\n    const expectedLength = sliceShape.reduce((a, b) => a * b)\n    const buffer = new DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[dtype](expectedLength)\n\n    let increment1D = 0\n    let incrementPos = min.slice()\n\n    while (incrementPos) {\n      let value = this.get(incrementPos)\n\n      // clamping the value on the provided dtype\n      if (value < DTYPE_TO_BOUND.min) {\n        value = DTYPE_TO_BOUND.min\n      } else if (value > DTYPE_TO_BOUND.max) {\n        value = DTYPE_TO_BOUND.max\n      }\n\n      buffer[increment1D] = value\n      incrementPos = NdRaster.getNextPosition(incrementPos, min, max)\n      increment1D += 1\n    }\n\n    const slice = new NdRaster({\n      data: buffer,\n      copy: false,\n      shape: sliceShape,\n    })\n\n    return slice\n  }\n\n\n  // TODO: maybe adjust the shape for lower dim\n  // write doc\n  thinSlice(position, options = {}) {\n    const min = this._shape.slice().fill(0)\n    const max = this._shape.slice().fill(Infinity)\n\n    position.forEach((v, i) => {\n      min[i] = v\n      max[i] = v + 1\n    })\n\n    return this.slice({ ...options, min, max })\n  }\n\n\n  /**\n   * The forEach() method execute the same callback function for each element of\n   * this NdRaster but does not modify its values unless the callback function does so.\n   * The callback function is called with the arguments:\n   * - {number} value - the value of this NdArray at this position\n   * - {Array} position - N-dimensional position, from slowest to fastest varying\n   * The callback is not expected to return any value.\n   * @param {Function} f - the callback function\n   */\n  forEach(f) {\n    if (typeof f !== 'function') {\n      throw new Error('The .forEach() method expects a function.')\n    }\n\n    this._bufferOffsetToPositionND()\n    for (let i = 0; i < this._data.length; i += 1) {\n      f( this._data[i], this._bufferOffsetToPositionND(i))\n    }\n  }\n\n\n\n\n\n  /**\n   * Within a N-dimensional bounding box (from min to max) and given a position in this bounding box,\n   * find the next N-dimensional position that is on the shortest distance in the 1D data buffer (minimize the buffer jump)\n   * @param {Array} position - N-dimensional position in an array such as [number, number, number, ...] from the slowest varying to the fastest\n   * @param {Array} min - N-dimensional position of the lower bound of the dataset. In an array such as [number, number, number, ...] from the slowest varying to the fastest\n   * @param {Array} max - N-dimensional position of the upper bound of the dataset. In an array such as [number, number, number, ...] from the slowest varying to the fastest\n   * @returns {Array|null} - the N-dimensional position that comes just after in the 1D data buffer. Or null if the next position is out of bound.\n   */\n  static getNextPosition(position, min, max) {\n    const nextPos = position.slice()\n\n    // trying to increment each position, from the fastest varying to the slowest.\n    for (let i = position.length - 1; i >= 0; i -= 1) {\n      // make sure the given position is within bounds\n      if (position[i] < min[i] || position[i] >= max[i]) {\n        return null\n      }\n\n      const dimIncreased = position[i] + 1\n\n      if (dimIncreased >= max[i]) {\n        // next position is out of bounding box\n        if (i === 0) {\n          return null\n        }\n\n        // back to the begining for this dim (the next slower one will be increased)\n        nextPos[i] = min[i]\n      } else {\n        nextPos[i] = dimIncreased\n        return nextPos\n      }\n    }\n\n    return null\n  }\n\n\n  /**\n   * @static\n   * Tells if a dtype is valid\n   * @param {string} dtype - a dtype as a string\n   * @returns {boolean}\n   */\n  static isValidDtype(dtype) {\n    return dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR\n  }\n\n\n  /**\n   * @static\n   * Tells the dtype of the given array. If no dtype is found, `null`  is returned.\n   * @param {*} arr - Some value that may or may not be a typed array\n   * @returns {string|null}\n   */\n  static guessDtype(arr) {\n    const dtypes = Object.keys(DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)\n    for (let i = 0; i < dtypes.length; i += 1) {\n      const dtype = dtypes[i]\n      if (arr instanceof DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[dtype]) {\n        return dtype\n      }\n    }\n    return null\n  }\n\n\n  /**\n   * @static\n   * Tells if a value is of type Array.\n   * Note: this function will return false if the value is a typed array\n   * @param {*} arr\n   */\n  static isGenericArray(arr) {\n    return (arr instanceof Array)\n  }\n\n\n  /**\n   * @static\n   * Get the shape of a nested array. A nested array is a generic Array that contains other arrays\n   * such as [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]] which a a 2D array of dimension ('C' ordered) [4, 3]\n   * @param {Array} arr - the potentially multidimensional nested array\n   * @returns {Array|null} Return a dimension array where the first element is the size of the slowest varying dimension\n   * and the last element is the fastest varying dimension. Returns null if the array is not valid\n   */\n  static getNestedArrayShape(arr) {\n    const shape = []\n\n    if (!Array.isArray(arr)) {\n      throw new Error('The value provided is not an Array')\n    }\n\n    let arrDigger = arr\n\n    while (Array.isArray(arrDigger)) {\n      const len = arrDigger.length\n      if (len === 0) {\n        throw new Error('An empty array cannot be used as data.')\n      }\n      shape.push(len)\n      arrDigger = arrDigger[0]\n    }\n\n    return shape\n  }\n\n\n  /**\n   * @static\n   * Flattens a nested Array and get the shape\n   * @param {Array} arr - a potentially nested Array\n   * @returns {Object} like {array: Array, shape: Array}\n   */\n  static flattenNestedArray(arr) {\n    const shape = NdRaster.getNestedArrayShape(arr)\n    const array = arr.flat(shape.length)\n    const expectedLength = shape.reduce((a, b) => a * b)\n\n    // this ensures that all the element in a given dimension have the same size\n    if (expectedLength !== array.length) {\n      throw new Error('The provided nested Array has size inconsistencies.')\n    }\n\n    return {\n      array,\n      shape,\n    }\n  }\n\n  static copyDataAsType(arr, targetDtype) {\n    if (!(targetDtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The target dtype is not valid.')\n    }\n\n    const guessedDtype = NdRaster.guessDtype(arr)\n\n    if (guessedDtype === targetDtype) {\n      return arr.slice()\n    }\n\n    const bounds = DTYPE_TO_BOUND[targetDtype]\n    const arrCopy = new DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[targetDtype](arr.length)\n    const length = arr.length\n\n    for (let i = 0; i < length; i += 1) {\n      let boundedValue = arr[i]\n      if (boundedValue < bounds.min) {\n        boundedValue = bounds.min\n      } else if (boundedValue > bounds.max) {\n        boundedValue = bounds.max\n      }\n      arrCopy[i] = boundedValue\n    }\n    return arrCopy\n  }\n}\n\nexport default NdRaster\n\n\n  // TODO:\n  // stat (min max)\n  // forEach\n  // simple operator + - / * (with scalar and other NdRasters) --> create a new one\n  // Constructor: data should be optional but at least one of data and shape must be provided","import NdRaster from './NdRaster'\n\nexport default ({\n  NdRaster,\n})\n"],"names":[],"mappings":"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"}