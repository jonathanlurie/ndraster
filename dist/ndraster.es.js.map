{"version":3,"file":"ndraster.es.js","sources":["../src/NdRaster.js","../src/index.js"],"sourcesContent":["\n/* global BigUint64Array, BigInt64Array */\n/* eslint no-undef: \"error\" */\n\nconst DEFAULT = {\n  dtype: 'float64',\n  copy: false,\n}\n\n\nconst DTYPE_TO_TYPEDARRAY_CONSTRUCTOR = {\n  uint8: Uint8Array,\n  int8: Int8Array,\n  uint16: Uint16Array,\n  int16: Int16Array,\n  uint32: Uint32Array,\n  int32: Int32Array,\n  uint64: BigUint64Array,\n  int64: BigInt64Array,\n  float32: Float32Array,\n  float64: Float64Array,\n}\n\nconst DTYPE_TO_NB_POSIBLE_VALUES = {\n  uint8: 2 ** (Uint8Array.BYTES_PER_ELEMENT * 8),\n  int8: 2 ** (Int8Array.BYTES_PER_ELEMENT * 8),\n  uint16: 2 ** (Uint16Array.BYTES_PER_ELEMENT * 8),\n  int16: 2 ** (Int16Array.BYTES_PER_ELEMENT * 8),\n  uint32: 2 ** (Uint32Array.BYTES_PER_ELEMENT * 8),\n  int32: 2 ** (Int32Array.BYTES_PER_ELEMENT * 8),\n  uint64: 2 ** (BigUint64Array.BYTES_PER_ELEMENT * 8),\n  int64: 2 ** (BigInt64Array.BYTES_PER_ELEMENT * 8),\n  float32: Infinity,\n  float64: Infinity,\n}\n\nconst DTYPE_TO_BOUND = {\n  uint8: {\n    min: 0,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint8 - 1,\n  },\n  int8: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int8 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int8 / 2 - 1,\n  },\n  uint16: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint16 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint16 / 2 - 1,\n  },\n  int16: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int16 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int16 / 2 - 1,\n  },\n  uint32: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint32 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint32 / 2 - 1,\n  },\n  int32: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int32 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int32 / 2 - 1,\n  },\n  uint64: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.uint64 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.uint64 / 2 - 1,\n  },\n  int64: {\n    min: -DTYPE_TO_NB_POSIBLE_VALUES.int64 / 2,\n    max: DTYPE_TO_NB_POSIBLE_VALUES.int64 / 2 - 1,\n  },\n  float32: {\n    min: -Infinity,\n    max: Infinity,\n  },\n  float64: {\n    min: -Infinity,\n    max: +Infinity,\n  },\n}\n\n\nclass NdRaster {\n  /**\n   * @constructor\n   * @param {Array|Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|BigUint64Array|BigInt64Array|Float32Array|Float64Array} data - can be a generic Array or one of the typedArray.\n   * If it is a generic Array, the values will be copied in a typed array (default dtype or dtype in the options object).\n   * If it is a typed array, a reference will be used and the values will not be copied, unless `options.copy` is explicitelly set to true or `options.dtype` does not matchc the type of the provided data.\n   * @param {Object} options - the options object\n   * @param {string} options.dtype - the data type to enforce the data to be. Must be one of 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', 'uint64', 'int64', 'float32', 'float64' (default: 'float64')\n   * @param {boolean} options.copy - if false, the inner data of the NdRaster instance will be a reference (unless another dtype is provided). If true, the data will be deep copied (default: false)\n   * @param {Array} options.shape - the shape to provide to the data, important to interpret the data as a multi-dimensional dataset.\n   *        Example: shape must be like [number, number, number] for a 3D matrix, where the first element is the size of the slowest dimension\n   *                 and the last element is the size of the fastest dimension. Numpy refers to this as the 'C' order, in opposition to the 'F' (Fortran) order.\n   *                 This order is also the default order used in Numpy.\n   *                 (default: single dimension of the size of the provided array)\n   */\n  constructor(arr, options = {}) {\n    const providedDtype = 'dtype' in options ? options.dtype : null\n    const copy = 'copy' in options ? (!!options.copy) : false\n    let shape = 'shape' in options ? options.shape : null\n\n    this._data = null\n    this._dtype = null\n    this._shape = null\n    this._strides = null\n\n    // if dtype provided in option but not valid, we throw an Error\n    if (providedDtype && !NdRaster.isValidDtype(providedDtype)) {\n      throw new Error(`The value ${providedDtype} is not a valid dtype.`)\n    }\n\n    const guessedDtype = NdRaster.guessDtype(arr)\n    const dtypeToUse = providedDtype ? providedDtype : DEFAULT.dtype\n    const isGenericArray = NdRaster.isGenericArray(arr)\n\n    if (isGenericArray\n    || (guessedDtype !== dtypeToUse && providedDtype)\n    || copy) {\n      let arrData = arr\n\n      // if a generic Array is provided, it could be a nested array\n      if (isGenericArray) {\n        const arrConfig = NdRaster.flattenNestedArray(arr)\n        arrData = arrConfig.array\n\n        // if no shape is provided, then we use the shape deduced by the flattening\n        if (!shape) {\n          shape = arrConfig.shape\n        }\n      }\n\n      this._data = NdRaster.copyDataAsType(arrData, dtypeToUse)\n      this._dtype = dtypeToUse\n    } else if (guessedDtype && copy) { // the type could be guessed but it was explicitely expressed to copy\n      this._data = NdRaster.copyDataAsType(arr, guessedDtype)\n      this._dtype = dtypeToUse\n    } else if (guessedDtype && !copy) { // the type could be guessed and it was not express to copy, we just assign\n      this._data = arr\n      this._dtype = guessedDtype\n    } else {\n      throw new Error('The provided data array is not valid.')\n    }\n\n    if (shape) {\n      this.shape = shape\n    } else {\n      this.shape = [this._data.length]\n    }\n\n    this._typeBound = DTYPE_TO_BOUND[this._dtype]\n  }\n\n\n  /**\n   * Define the shape of the data.\n   * @param {Array} shape - the shape to provide to the data, important to interpret the data as a multi-dimensional dataset.\n   *        Example: shape must be like [number, number, number] for a 3D matrix, where the first element is the size of the slowest dimension\n   *                 and the last element is the size of the fastest dimension. Numpy refers to this as the 'C' order, in opposition to the 'F' (Fortran) order.\n   *                 This order is also the default order used in Numpy.\n   *                 (default: single dimension of the size of the provided array)\n   */\n  set shape(shape) {\n    let total = 1\n\n    if (!Array.isArray(shape)) {\n      throw new Error('The shape must be an Array')\n    }\n\n    for (let i = 0; i < shape.length; i += 1) {\n      total *= shape[i]\n    }\n\n    if (total !== this._data.length) {\n      throw new Error('The shape does not match the size of the data. All the elements of the shape multiplied must be the total number of element in the data.')\n    }\n\n    this._shape = shape.slice()\n    this._strides = new Array(shape.length).fill(0)\n    this._strides[this._shape.length - 1] = 1\n\n    for (let i = this._shape.length - 2; i >= 0; i -= 1) {\n      this._strides[i] = this._shape[i + 1] * this._strides[i + 1]\n    }\n  }\n\n\n  /**\n   * Get the shape of this NdRaster (or rather a copy of it)\n   * @returns {Array}\n   */\n  get shape() {\n    return this._shape.slice()\n  }\n\n\n  /**\n   * Get the dtype as a string (read only)\n   * @returns {string}\n   */\n  get dtype() {\n    return this._dtype\n  }\n\n\n  /**\n   * Get the stride (read only)\n   */\n  get strides() {\n    return this._strides.slice()\n  }\n\n\n  /**\n   * Get the raw data as a 1D typed array with data arranged in 'C' order\n   * @returns {TYpedArray}\n   */\n  get data() {\n    return this._data\n  }\n\n\n  /**\n   * Get the minimum and maximum values possible by the dtype.\n   * Note: this is not the data min-max\n   * @return {Object} of shape {min: number, max: number}\n   */\n  get bounds() {\n    // making it read only to prevent any modification\n    return {\n      min: this._typeBound.min,\n      max: this._typeBound.max,\n    }\n  }\n\n\n  /**\n   * Get the number of dimensions in this NdRaster\n   * @returns {number}\n   */\n  get dimensions() {\n    return this._shape.length\n  }\n\n\n  /**\n   * Get the value at a given position\n   * @param {Array} position - the position as [number, number, ...] with as many components as there are dimensions in the NdRaster.\n   * @returns {number}\n   */\n  get(position) {\n    this._throwIfInvalidPosition(position)\n\n    let dataOffset = 0\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    return this._data[dataOffset]\n  }\n\n\n  /**\n   * Set the value at a given position.\n   * This value is bounded to the dtype capabilities to prevent looping,\n   * for example, is dtype is 'uint8' and a value is set at 300, then the actual\n   * value put in the NdRaster will be 255, as it is the maximum value possible for 'uint8' type.\n   * Know more about the boudaries for this NdRaster with the attribute `.bounds`\n   * @param {Array} position - position to change to change the value of. Must contain as many elements as there are dimensions in this NdRaster\n   * @param {number} value\n   */\n  set(position, value) {\n    // eslint-disable-next-line no-restricted-globals\n    if (isNaN(value)) {\n      throw new Error('The value must be a number')\n    }\n\n    this._throwIfInvalidPosition(position)\n\n    let boundedValue = value\n    let dataOffset = 0\n\n    if (value < this._typeBound.min) {\n      boundedValue = this._typeBound.min\n    }\n\n    if (value > this._typeBound.max) {\n      boundedValue = this._typeBound.max\n    }\n\n    for (let i = 0; i < position.length; i += 1) {\n      dataOffset += position[i] * this._strides[i]\n    }\n\n    this._data[dataOffset] = boundedValue\n  }\n\n\n\n\n\n  /**\n   * @private\n   * Throw an error if position is invalid.\n   * @param {*} position\n   */\n  _throwIfInvalidPosition(position) {\n    if (position.length !== this._shape.length) {\n      throw new Error(`The position argument contains ${position.length} elements instead of ${this._shape.length}.`)\n    }\n\n    for (let i = 0; i < position.length; i += 1) {\n      if (position[i] < 0 || position[i] > this._shape[i] - 1) {\n        throw new Error(`The position components ${i} is out of bound. Must be in [0, ${this._shape[i] - 1}]`)\n      }\n    }\n  }\n\n\n  copy(options = {}) {\n    const dtype = 'dtype' in options ? options.dtype : this._dtype\n\n    if (!(dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The provided dtype is not valid')\n    }\n\n    let dataCopy = null\n    if (dtype === this._dtype) {\n      dataCopy = this._data.slice()\n    } else {\n      dataCopy = NdRaster.copyDataAsType(this._data, dtype)\n    }\n\n    const copy = new NdRaster(dataCopy, {\n      copy: false,\n      shape: this.shape,\n    })\n    return copy\n  }\n\n\n  /**\n   * \n   * @param {*} start \n   * @param {*} end \n   */\n  slice(start, end) {\n\n  }\n\n\n  /**\n   * @static\n   * Tells if a dtype is valid\n   * @param {string} dtype - a dtype as a string\n   * @returns {boolean}\n   */\n  static isValidDtype(dtype) {\n    return dtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR\n  }\n\n\n  /**\n   * @static\n   * Tells the dtype of the given array. If no dtype is found, `null`  is returned.\n   * @param {*} arr - Some value that may or may not be a typed array\n   * @returns {string|null}\n   */\n  static guessDtype(arr) {\n    const dtypes = Object.keys(DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)\n    for (let i = 0; i < dtypes.length; i += 1) {\n      const dtype = dtypes[i]\n      if (arr instanceof DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[dtype]) {\n        return dtype\n      }\n    }\n    return null\n  }\n\n\n  /**\n   * @static\n   * Tells if a value is of type Array.\n   * Note: this function will return false if the value is a typed array\n   * @param {*} arr\n   */\n  static isGenericArray(arr) {\n    return (arr instanceof Array)\n  }\n\n\n  /**\n   * @static\n   * Get the shape of a nested array. A nested array is a generic Array that contains other arrays\n   * such as [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]] which a a 2D array of dimension ('C' ordered) [4, 3]\n   * @param {Array} arr - the potentially multidimensional nested array\n   * @returns {Array|null} Return a dimension array where the first element is the size of the slowest varying dimension\n   * and the last element is the fastest varying dimension. Returns null if the array is not valid\n   */\n  static getNestedArrayShape(arr) {\n    const shape = []\n\n    if (!Array.isArray(arr)) {\n      throw new Error('The value provided is not an Array')\n    }\n\n    let arrDigger = arr\n\n    while (Array.isArray(arrDigger)) {\n      const len = arrDigger.length\n      if (len === 0) {\n        throw new Error('An empty array cannot be used as data.')\n      }\n      shape.push(len)\n      arrDigger = arrDigger[0]\n    }\n\n    return shape\n  }\n\n\n  /**\n   * @static\n   * Flattens a nested Array and get the shape\n   * @param {Array} arr - a potentially nested Array\n   * @returns {Object} like {array: Array, shape: Array}\n   */\n  static flattenNestedArray(arr) {\n    const shape = NdRaster.getNestedArrayShape(arr)\n    const array = arr.flat(shape.length)\n    const expectedLength = shape.reduce((a, b) => a * b)\n\n    // this ensures that all the element in a given dimension have the same size\n    if (expectedLength !== array.length) {\n      throw new Error('The provided nested Array has size inconsistencies.')\n    }\n\n    return {\n      array,\n      shape,\n    }\n  }\n\n  static copyDataAsType(arr, targetDtype) {\n    if (!(targetDtype in DTYPE_TO_TYPEDARRAY_CONSTRUCTOR)) {\n      throw new Error('The target dtype is not valid.')\n    }\n\n    const guessedDtype = NdRaster.guessDtype(arr)\n\n    if (guessedDtype === targetDtype) {\n      return arr.slice()\n    }\n\n    const bounds = DTYPE_TO_BOUND[targetDtype]\n    const arrCopy = new DTYPE_TO_TYPEDARRAY_CONSTRUCTOR[targetDtype](arr.length)\n    const length = arr.length\n\n    for (let i = 0; i < length; i += 1) {\n      let boundedValue = arr[i]\n      if (boundedValue < bounds.min) {\n        boundedValue = bounds.min\n      } else if (boundedValue > bounds.max) {\n        boundedValue = bounds.max\n      }\n      arrCopy[i] = boundedValue\n    }\n    return arrCopy\n  }\n}\n\nexport default NdRaster\n\n\n  // TODO:\n  // copy/clone/astype\n  // stat (min max)\n  // get multiple values at once (all dim) --> slice\n  // forEach\n  // simple operator + - / * (with scalar and other NdRasters) --> create a new one\n  // Constructor: data should be optional but at least one of data and shape must be provided","import NdRaster from './NdRaster'\n\nexport default ({\n  NdRaster,\n})\n"],"names":[],"mappings":"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"}